# Проект react-component-server-axios-kit.

## ВТОРАЯ ЧАСТЬ ПРОЕКТА react-component.
Для реализации, как базу, нужно взять проект из репозитория: https://github.com/Mikey191/react-component-toolkit

Установить зависимость для анимации: npm install react-transition-group --save

## Содержание второй части проекта:
- ЖИЗНЕННЫЙ ЦИКЛ КОМПОНЕНТА. useEffect.
- API. PostService.
- ИНДИКАЦИЯ ЗАГРУЗКИ ДАННЫХ С СЕРВЕРА.
- КОМПОНЕНТ LOADER. АНИМАЦИЯ.
- КАСТОМНЫЙ ХУК useFetching(). ОБРАБОТКА ОШИБОК.
- ПОСТРАНИЧНЫЙ ВЫВОД. ПАГИНАЦИЯ (PAGINATION)
- REACT ROUTER. ПОСТРАНИЧНАЯ ПАГИНАЦИЯ.
- ДИНАМИЧЕСКАЯ НАВИГАЦИЯ. useNavigate, useParams.
- ЗАГРУЗКА КОММЕНТАРИЕВ К ПОСТУ.
- ПРИВАТНЫЕ И ПУБЛИЧНЫЕ МАРШРУТЫ. УЛУЧШАЕМ НАВИГАЦИЮ.
- ГЛОБАЛЬНЫЕ ДАННЫЕ. АВТОРИЗАЦИЯ ПОЛЬЗОВАТЕЛЯ. useContext.
- БЕСКОНЕЧНАЯ ЛЕНТА. ДИНАМИЧЕСКАЯ ПАГИНАЦИЯ. useObserver.


В проекте **react-component-server-axios-kit** будет сервер, который называется **jsonplaceholder**, он позволяет получать некоторое количество данных.
У jsonplaceholder есть набор endpoint'ов для запросов:
/posts
/comments
/albums
/photos
/todos
/users

Мы будем взаимодействовать с endpoint'ом /posts который доступен по ссылки [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts).
Для того, что бы делать запросы, нам понадобится библиотека, которая называется axios.
Установить axios: **npm i axios**

## 1.	ФУНКЦИЯ ДЛЯ ЗАПРОСОВ. РАБОТА С СЕРВЕРОМ AXIOS.	
    1.	 Реализуем асинхронную функцию fetchPosts(), которая будет отправлять запрос на сервер, получать какие то данные и помещать их в наше состояние с постами.
    2.	 В функции создаем переменную response куда будет помещен результат выполнения запроса. Запрос будет реализован с помощью await axios.get("https://jsonplaceholder.typicode.com/posts");
    3.	 Добавляем массив постов, который получаем с сервера в массив наших постов posts с помощью функции setPosts. Все посты будут храниться в аргументе response.data .
    4.	 Для проверки создадим кнопку, которая будет вызывать функцию fetchPosts().
		
## 2.	ЖИЗНЕННЫЙ ЦИКЛ КОМПОНЕНТА. useEffect	
    1.	 Каждый компонент обладает жизненным циклом, который в свою очередь проходит в три этапа: Монтирование (mount); Обновление (update); Размонтирование (unmout). Для загрузки всех постов при запуске приложения будем использовать хук useEffect(). В callback'e хука будем вызывать функцию подгрузки постов.
    2.	 В зависимостях у хука мы не будем ничего отслеживать. Такой функционал позволит нам подгрузить все посты единожды, при первой загрузке приложения.
    3.	 Создаем в App.js хук useEffect с нужными настройками (вызов функции и пустой массив зависимостей).
		
## 3.	API. PostService.	
    1.	 Создадим папку API в src.
    2.	 В ней создаем файл с названием PostService.js.
    3.	 Создаем одноименный класс. Внутри класса будет одна единственная функция, которая будет называтся getAll. Это будет статичная асинхронная функция, возвращающая список постов.
    4.	 Из файла App.js скопируем запрос и переносим в новую функцию. 
    5.	 Возвращать из этой функции будем список постов.
    6.	 Так же сразу попробуем отловить ошибку, если она последует.
    7.	 Оборачиваем код в try catch.
    8.	 Возвращаемся в App.js в функцию fetchPosts(). И заменяем запрос к адресу на функцию из класса PostService.
		
## 4.	ИНДИКАЦИЯ ЗАГРУЗКИ ДАННЫХ С СЕРВЕРА.	
    1.	 Когда мы перезагружаем страницу на мгновение (пока посты не подгрузились) у нас появляется наша надпись "Посты не найдены". Вместо надписи мы можем создать лоадер и подгружать его во время загрузки. Для этого в файле App.js создадим состояние isPostsLoading, setIsPostsLoading равное false по дефолту.
    2.	 В функции fetchPosts мы меняем его на true перед тем как сделать запрос на сервер, и обратно в false после того как загрузка завершена.
    3.	 И в зависимости от этого состояния нам необходимо что-то нарисовать в шаблоне. Создадим условие перед списком постов где будем показывать крутилку, если значение isPostsLoading = true. Иначе грузим посты.
		
## 5.	КОМПОНЕНТ LOADER. АНИМАЦИЯ.	
    1.	 Вместо надписи сделаем loader. В папке UI создаем папку Loader.
    2.	 В папке создаем компонент внутри будет div.loader .
    3.	 Помещаем его в <MyModal> с пропсом visible={true}
    4.	 В папке создаем файл стилей для компонента. Содержание: .loader{ width: 100px; height: 100px; border-radius: 50%; border: 3px dashed teal; }
    5.	 Помещаем получившийся компонент вместо надписи "Идет загрузка...".
    6.	 Переходим обратно к компоненту Loader и разберемся с анимацией.
    7.	 Открываем стили и создадим ключевые кадры с помощью ключевого слова @keyframes.
    8.	 В нашем случае у нас будет всего два ключевых кадра: @keyframes rotate { from{  transform: rotate(0deg) scale(1); } to{  transform: rotate(360deg) scale(1.2); }}
    9.	 Далее добавим анимацию на класс: .loader {  animation: rotate 1s infinite linear;}
		
## 6.	КАСТОМНЫЙ ХУК useFetching(). ОБРАБОТКА ОШИБОК.	
    1. 	Функционал с крутилкой может нам понадобится и дальше, поэтому сделать переиспользуемый функционал. Создадим еще один хук и назовем его useFetching.js.
    2. 	Экспортируем одноименную функцию. Аргументом функция будет принимать некоторый callback - это будет запрос, перед которым крутилку надо показать, и после выполнения которого крутилку надо будет скрыть.
    3. 	Создаем внутри хука состояние - это будет состояние которое отвечает за загрузку isLoading, setIsLoading. По дефолту состояние будет false.
    4. 	Так же базовый кейс - это обработка ошибок. Если у нас запрос прошел с ошибкой, и эту ошибку необходимо как-то показать. Создаем для этого состояние по умолчание которое будет - пустая строка error, setError.
    5. 	Далее создаем функцию fetching. 
    6. 	Функционал этой функции обернем в try catch с блоком finally.
    7. 	В try мы изменяем состояние isLoading на true для того, чтобы показалась крутилка.
    8. 	В блоке finally независимо от того, произошла ошибка или нет мы устанавливаем значение isLoading на false.
    9. 	Затем в try мы должны вызвать callback, который приняли аргументом. Чаще всего это будет асинхронная функция, добавляем async для функции fetching и вызывать callback будем через await.
    10.	Если произошла ошибка, то мы с помощью setError помещаем в переменную error сообщение об ошибки er.message.
    11.	Из хука мы возвращаем: функцию fetching что бы мы могли ее вызвать; состояние isLoading; сообщение об ошибки.
    12.	Воспользуемся хуком useFetching(). Переходим в файл App.js .
    13.	Удаляем состояние isPostsLoading.
    14.	Вызываем хук useFetching, будем деструктуризировать его в список. Передаем туда некоторый асинхронный callback.
    15.	В callback'e необходимо сделать функционал, который у нас уже был: получить посты с сервера и поместить их в состояние.
    16.	Функция fetchPosts нам больше не нужна.
    17.	Деструктуризируем то, что нам вернет хук useFetching: [fetchPosts, isPostsLoading, postError]
    18.	И сразу же обработаем некоторую ошибку. Над условием isPostsLoading добавим еще проверку: если в postError у нас что то находится, то будем выводить заголовок "Произошла ошибка ${postError}": { postError && <h1>Произошла ошибка ${postError}</h1> }. Проверить это можно поломав немного url откуда мы подтягиваем посты.
    19.	В PostService мы можем не помещать все в try catch, потому что ловить ошибку мы будем с помощью хука useFetching.
		
## 7.	ПОСТРАНИЧНЫЙ ВЫВОД. ПАГИНАЦИЯ (PAGINATION)	
    1. 	Сделаем пагинацию, что бы на страницы отображались не все сто постов, а по 10 на странице. Для этого нам понадобятся query параметры: _limit=10 - он сообщает серверу, сколько постов нужно вернуть; _page=2 - это номер страницы. Запрос будет теперь выглядеть вот так: https://jsonplaceholder.typicode.com/posts?_limit=10&_page=2
    2. 	В настройках консоли разработчика для страницы jsonplaceholder, во вкладке headers мы можем найти x-total-count: 100 - это общее количество постов, которое может вернуть сервер. И на основании этой цифры мы можем посчитать общее кол-во страниц, отрисовать, что бы пользователь мог нажимать и получать новую порцию данных. Переходим в файл PostService.js .
    3. 	В функции будем возвращать сам response, поскольку нам необходимо будет обращаться к header и вытаскивать общее кол-во постов.
    4. 	Переходим к App.js
    5. 	Создадим состояние, в которое мы будем помещать общее количество постов totalCount, setTotalCount.
    6. 	И после того как мы этот ответ получили в useFetching(), обращаемся к headers ответа и находим в них x-total-count: setTotalCount(response.headers["x-total-count"]).
    7. 	Так же можем вывести его в логи.
    8. 	Теперь нам надо передавать те самые параметры _limit и _page. Перейдем в файл PostService.js .
    9. 	Функция у нас будет принимать limit=10 и page=1.
    10.	Далее передаем эти параметры в запрос. У axios есть изящный способ передачи в строку этих значений: axios.get( "https://jsonplaceholder.typicode.com/posts", { params: { _limit: limit, _page: page }});
    11.	Возвращаемся в App.js .
    12.	Нам необходима теперь в функцию getAll эти парметры передать. И для лимита, и для номера страницы создадим отдельные состояние: limit, setLimit; page, setPage.
    13.	Передаем эти параметры в getAll в хуке useFetching.
    14.	Теперь jsonplaceholder вернет нам x-total-count и в логах мы получаем число 100.
    15.	Поделив это число на limit, мы найдем сколько всего у нас должно быть страниц.
    16.	Создадим папку utils в которой будут различные вспомогательные функции. Выделим там работу с номерами страниц.
    17.	Создаем файл pages.js
    18.	В файле реализовываем функцию getPageCount. Аргументами будет принимать общее количество элементов totalCount и лимит, который должен быть на странице limit, а возвращать необходимое количесвто страниц. При расчете страниц нам необходимо будет округлять количество страниц в большую сторону. Это можно сделать с помощью функции Math.ceil .
    19.	Переходим в App.js .
    20.	Состояние totalCount меняем на totalPages. В этой переменной будем хранить общее количество страниц.
    21.	Переходим к useFetch и меняем в ней setTotalCount на setTotalPages.
    22.	Остается правильно подставить все что мы сделали в папке utils. Из хедера мы достаем общее количество постов. Для этого в хуке делаем переменную totalCount.
    23.	И теперь общее количество постов и лимит передать в функцию: settotalPages(getPageCount(totalCount, limit));.
    24.	Зная общее количество страниц мы можем сформировать массив в котором значения идут от одного до десяти, и на основании этого массива нарисовать кнопки при нажатии на которые будет меняться страница.
    25.	Перед useFetching создадим переменную pagesArray - это будет массив который будет заполнятся числами из цикла. Он будет пересчитываться при каждом рендере.
    26.	Сделаем декомпозицию и вынесем функционал в отдельную функцию.
    27.	Переходим в файл pages.js .
    28.	Делаем функцию getPagesArray которая принимает общее кол-во страниц и на основании этого количества заполняем массив и возвращаем заполненный массив.
    29.	Переходим обратно в App.js .
    30.	Вызываем эту функцию при создании переменной pagesArray.
    31.	В нее передаем состояние totalPages.
    32.	На основании этого массива мы можем нарисовать кнопки. Переходи в конец компонента App, итерируемся с помощью map по этому компоненту.
    33.	Для каждого элемента создаем кнопку и внутрь кнопки помещаем номер страницы: <div className="page__wrapper">{pagesArray.map((p) => <span className="page">{p}</span> )} </div> .
    34.	Переходим в App.css и напишем стили для этих классов: .page__wrapper{ margin-top: 30px; display: flex;}; .page{  padding: 10px;  border: 1px solid teal;  cursor: pointer;}.
    35.	Для того что бы показать визуально, что какая то страница выбрана создадим еще один класс в App.css: .page__current {  border: 1px solid orange;  font-weight: bold;}.
    36.	По условию этот класс нужно добавлять. Изменим немного кострукцию в span: <div className="page__wrapper"> {pagesArray.map((p) => ( <span className={page === p ? "page page__current" : "page"}> {p} </span> ))} </div>.
    37.	Добавляем ключ в span key={p}.
    38.	Реализуем обработку нажатия на span и в этом случае будем изменять состояние page с помощью setPage(p): <span onClick={() => setPage(p)} key={p} className={page === p ? "page page__current" : "page"}>.
    39.	Остается подгружать новую порцию данных. Реализуем функцию changePage где будем устанавливать page с помощью setPage.
    40.	Повесим на onClick и аргументом будем передавать p.
    41.	Когда мы изменили номер страницы необходимо вызвать функцию setPosts с новыми параметрами.
    42.	В App.js в хуке useFetch() в функцию-callback передаем limit и page.
    43.	И передавать их при вызове функции в useEffect.
    44.	В функции changePage мы эту функцию fetchPosts можем вызвать и туда передать номер той страницы, на которую нажал пользователь.
    45.	Что бы эти аргументы попали в функцию перейдем в файл useFetching и в функции fetching аргументы принять и передать в callback const fetching = async (...args) => await callback(...args).
    46.	Вынесем страницы в отдельный компонент. Создаем в папке UI папку pagination.
    47.	Разворачиваем компонент и переносим код из App.js . В этом компоненте необходимо получать номер текущей страницы, функция которая этот номер изменяет и массив на основании которого необходимо отрисовывать элементы: totalPages, page, changePage. Для создания массива нам надо знать сколько у нас страниц.
    48.	Затем нам надо получать номер текущей страницы и функция, которая текущую страницу изменяет.
    49.	Формируем массив с помощью функции getPagesArray.
    50.	Вернемся обратно в App.js и воспользуемся этим компонентом. Передаем туда пропсы: номер страницы; функция которая этот номер изменяет; общее количество страниц.
    51.	Для наглядности можно в компоненте PostsList можно поменять number с index+1 на post.id.
		
## 8.	REACT ROUTER. ПОСТРАНИЧНАЯ ПАГИНАЦИЯ.	
    1. 	Реализуем постраничную пагинацию с помощью библиотеки react-router-dom. Устанавливаем с помощью команды: npm install react-router-dom.
    2. 	Сейчас у нас весь код находится в компоненте App. Создадим еще одну папку в src проекта, которую назовем pages. Она будет содержать в себе компонентами, которые практически будут страницами.
    3. 	Сразу создадим компонент Posts.jsx. Это будет та страница, которая у нас уже есть.
    4. 	Весь код из App копируем и вставляем в Posts.
    5. 	Поменять название того, что экспортируется, и соответственно саму функцию тоже.
    6. 	Давайте что бы страниц было больше создадим в папке pages еще один компонент About.jsx.
    7. 	Логики прописывать не будем, просто сделаем заголовок что бы видеть, что страница переключилась.
    8. 	Из App удаляем всю начинку, она нам больше не нужна. И в этой функции будем реализовывать роутинг.
    9. 	Для того, чтобы объявить какой-то маршрут (какую-то страницу) react-router-dom предоставляем компонент, который называется Route.
    10.	Полная конструкция выглядит следующим образом: <BrowserRouter> <Routes> <Route path="/about" element={<About/>} /> </Routes> </BrowserRouter>
    11.	Создадим второй такой маршрут, который будет отрисовывать список постов: <Route path="/posts" element={<Posts/>} />.
    12.	Так же нам необходимо переделать import'ы в файле Posts.jsx .
    13.	Реализуем динамическое передвижение по маршрутам. Что бы при нажатии на элементы переходило на те или иные страницы.
    14.	Создадим блок div внутри <BrowserRouter> и над <Routes>: <div className="navbar"> <div className="navbar__links"> <a href="/about">О сайте</a>  <a href="/posts">Посты</a> </div> </div>. Это будет наша навигационная панель.
    15.	Далее дополним стили для нашего navbar:
    16.	.navbar{  height: 50px;  width: 100%;  display: flex;  align-items: center;  padding: 0 15px;  background: gray;}.
    17.	Так же выставим весь контент root  в колонку: #root {  display: flex;  flex-direction: column;  align-items: center;}.
    18.	При нажатии на ссылки вся страница обновляется. Для того, что бы это исправить необходимо использовать компонент Link из react-router-dom и вместо тега href использовать пропс, которой называется to: <div className="navbar__links"> <Link to="/about">О сайте</Link> <Link to="/posts">Посты</Link> </div>.
    19.	Следующая проблема несуществующий url. Этот случай необходимо обработать. А так же вынести наш navbar в еще один компонент в нашей библиотеке.
    20.	В папки UI создаем папку Navbar в ней создаем компонент Navbar.jsx .
    21.	Переносим в него код связанный с navbar.
    22.	Возвращаемся обратно в App.js И добавляем компонент.
    23.	При несуществующем url нужно сбрасывать адрес до дефолтного. Это можно сделать с помощью следующей конструкции: <Route path="*" element={<Navigate to="/posts" />} />.
    24.	Создадим еще одну страницу с ошибкой Error.jsx .
    25.	В ней так же будет только заголовок с надписью "Вы перешли на несуществующую страницу!".
    26.	Объявляем этот адрес в App.js: <Route path="/error" element={<Error />} /> и переделываем: <Route path="*" element={<Navigate to="/error" />} />
    27.	Создадим для всех маршрутов отдельный компонент. Назовем его AppRouter.jsx .
    28.	Из App перенесем функционал в этот файл.
    29.	Переходим в App.js и этот роутер добавляем.
		
## 9.	ДИНАМИЧЕСКАЯ НАВИГАЦИЯ. useNavigate, useParams.
    1. 	Добавим еще одну кнопку для поста. Эта кнопка будет открывать страницу для конкретного поста. Так же на этой страницы будут комментарии, который к посту оставляют пользователи. Переходим в компонент PostItem.jsx и создаем еще одну кнопку внутри которой напишем "открыть".
    2. 	Подправим стили для post__btns: .post__btns{  display: flex;} .
    3. 	Теперь нам надо реализовать динамическую навигацию, что бы для каждого поста была своя ссылка. Переходы на другие страницы мы так же можем осуществлять с помощью хука useNavigate. Создадим переменную const router = useNavigate().
    4. 	Теперь осуществить переход по адресам возможно с помощью, например, router('/about') в onClick.
    5. 	Нам нужно переходит по страницам самих новостей. Сделаем динамический адрес: onClick={() => router(`/posts/${props.post.id}`)}.
    6. 	Нужно сделать соответствующий роут для этих маршрутов. Создадим в pages новый компонент PostIdPage.jsx который будет формироваться из информации из поста.
    7. 	Пока как заглушку сделаем h1 заголовок "Вы открыли страницу поста".
    8. 	Следующим этапом создадим роут, который будет отрисовывать этот компонент. Переходим в файл AppRouter.jsx .
    9. 	Добавляем еще один маршрут: <Route path="/posts/:id" element={<PostIdPage />} />, где :id в адресе - это динамическая переменная, которая будет подставляться после /posts/.
    10.	В path где есть posts реакт воспринимает путь как просто /posts. Что бы такого не было необходимо добавить слово exact: <Route exact path="/posts" element={<Posts />} />, <Route exact path="/posts/:id" element={<PostIdPage />} />.
    11.	Теперь мы можем этот id из url выцепить и на основании этого id отправить запрос на сервер для получения поста по id. Для того, что бы этот параметр выцепить необходимо воспользоваться хуком useParams из react-router-dom. Объект этого хука возвращает объект с полем id:номер.
    12.	Используя этот id, мы можем менять содержимое страницы в зависимости от того, какой id приходит, так как в jsonplaceholder есть возможность обращаться так же по номеру поста. Например: https://jsonplaceholder.typicode.com/posts/2 - вернет нам пост с номером 2.
    13.	Теперь займемся запросом на сервер и получением нужной для нас информации. Для этого у нас есть PostService.js . Открываем файл и создаем в нем новую функцию getById(id). Строка запроса будет выглядеть вот так: "https://jsonplaceholder.typicode.com/posts/" + id .
    14.	Переходим обратно в PostIdPage.
    15.	Воспользуемся хуком useEffect, где мы будем на первую отрисовку компонента получать данные с сервера (оставим пока пустым).
    16.	Так же для отправки запросов мы уже сделали переиспользуемый хук useFetching. Внутри callback'a мы дергаем PostService и метод getById. id достаем из параметров: useFetching(async () => {const response = await PostService.getById(params.id)});
    17.	Далее нам необходимо создать состояние post, setPost c пустым объектом в дефолтном состоянии. В useFetching в это состояние поместить то, что нам вернет сервер, а именно post. 
    18.	После того, как мы получили ответ от сервера помещаем поле date в состояние, внутри хука useFetching: setPost(response.data);
    19.	Остается вызвать функцию, которую нам вернул хук в useEffect c параметром params.id . Так же в функцию коллбэка хука useFetching лучше передавать id и таким образом можно потом на него реагировать.
    20.	Информацию о посте выведим в шаблон: <div>{post.id}. {post.title}</div>.
    21.	Обработаем состояние загрузки: если isLoading true то будем показывать loader, в обратном случае будем показывать блок div.
		
## 10.	ЗАГРУЗКА КОММЕНТАРИЕВ К ПОСТУ.	
    1. 	У jsonplaceholder есть возможность по id поста получить список комментариев к нему.
    2. 	url будет выглядеть таким образом: https://jsonplaceholder.typicode.com/posts/7/comments .
    3. 	В файле PostIdPage.jsx добавим заголовок для наших комментов.
    4. 	Необходимо реализовать запрос на получение комментариев. Для этого воспользуемся так же, как и с постами хуком useFetching.
    5. 	Необходимо реализовать функцию внутри PostService.js которая эти комментарии будет получать. Параметром функции будет id. get-запрос будет выглядеть так: `https://jsonplaceholder.typicode.com/posts/${id}/comments` .
    6. 	Возвращаемся обратно в PostIdPage.jsx, во втором useFetching вызываем метод который мы только что сделали: const response = await PostService.getCommentsById(id);
    7. 	Создадим состояние для комментариев comments, setComments. По дефолту - пустой список.
    8. 	Сохраним в переменную comments response.data .
    9. 	В функции useEffect мы вызываем функцию fetchComments с аргументом params.id .
    10.	Остается эти комментарии отрисовать. По условию с проверкой isComLoading выводим результат: <div> {comments.map((comm) => ( <div style={{ marginTop: 30 }}> <h5>{comm.email}</h5> <div>{comm.body}</div> </div> ))}</div>
		
## 11.	ПРИВАТНЫЕ И ПУБЛИЧНЫЕ МАРШРУТЫ. УЛУЧШАЕМ НАВИГАЦИЮ.	
    1. 	Если сейчас мы попытаемся загрузить стартовую страницу, то нас перебросит на страницу с ошибкой. Давайте это поправим. Переходим в AppRoute.jsx .
    2. 	По дефолту сделаем редирект на страницу с постами.
    3. 	Создаем еще одну папку в дирректории src, и назовем ее router.
    4. 	Создадим внутри файл, который назовем routes.js .
    5. 	И из этого файла мы будем экспортировать константу, которую проинициализируем массивом. Это будут обычные объекты, содержащие нужные для нас поля: {  path - маршрут;  About - компонент, который должен по маршруту отрисоваться;  exact: true}.
    6. 	Перейдем обратно в AppRouter.jsx .
    7. 	Итерируясь по созданному массиву с помощью функции map будем генерировать нужные маршруты: 
    8. 	{routes.map((route) => (<Route key={route.path} path={route.path} element={<route.component />} exact={route.exact} />))}.
    9. 	Сделаем так, чтобы некоторые маршруты были доступны только авторизованным пользователем. Создадим страницу Login.jsx.
    10.	В компоненте будет заголовок, форма => MyInput(логин), MyInput(пароль), MyButton(Войти).
    11.	Нам необходимо в routes.js создать массив для авторизованных пользователей и неавторизованных пользователей.
    12.	Первый массив privateRoutes, где будут все пути навигации.
    13.	Второй массив publicRoutes, где будет только component: Login.
    14.	В AppRouter.jsx правильно распределим эти маршруты.
    15.	Для этого нужно где-то хранить информацию, авторизован пользователь или нет. Это будет сonst isAuth = true; созданный пока в AppRouter.jsx.
    16.	И в зависимости от этого флага у нас будет авторизованный или неавторизованный маршрут.
    17.	Поскольку проект без бэка мы сделаем просто заглушку, в которой на страницы при нажатии кнопки Войти будем менять значение переменной isAuth.
		
## 12.	ГЛОБАЛЬНЫЕ ДАННЫЕ. АВТОРИЗАЦИЯ ПОЛЬЗОВАТЕЛЯ. useContext.	
    1. 	Доступ к переменной isAuth может понадобится во многих модулях нашего приложения. Оставлять ее просто внутри AppRouter нет возможности. Реализуем этот функционал с помощью useContext(context). С помощью context мы можем создать некоторое глобальное хранилище и из любого компонента к этому глобальному хранилищу обращаться. Создаем папку context и внутри создаем index.js файл.
    2. 	Экспортируем константу AuthContext, и из реакта нам понадобится функция createContext(null), чтобы присвоить в эту переменную.
    3. 	Что бы им воспользоваться нам необходимо вызвать <AuthContext.Provider> и внутрь него засунуть все наше приложение. Переходим в файл App.js и оборачиваем наше приложение которое возвращает функция App в <AuthContext.Provider>.
    4. 	Создаем состояние isAuth setIsAuth.
    5. 	isAuth setIsAuth передаем в контекст в параметре value как объект с полями.
    6. 	Откроем компонент AppRouter и здесь необходимо доступ к этой переменной isAuth получить. Для этого будем использовать хук useContext() и как аргумент передаем туда context: const {isAuth, setIsAuth} = useContext(AuthContext).
    7. 	При нажатии на кнопку "войти" нам необходимо менять это состояние на тру и редиректить на страницу с постами. Откроем компонент Login.
    8. 	Повесим слушатель события onSubmit на форму и будем вызывать функцию login.
    9. 	Функцию реализуем чуть выше: Остановим превентивное действие event, и так же нам нужно из contexta получить isAuth и setIsAuth.
    10.	Внутри функции login вызваем setIsAuth и изменить состояние на true.
    11.	Теперь нам необходимо реализовать кнопку "выйти". Эту кнопку мы будем делать в Navbar.jsx.
    12.	Добавляем кнопку Выйти.
    13.	Для реализации этого функционала опять воспользуемся хуком useContext и получим нужные для нас данные.
    14.	Вешаем слушатель события на кнопку и при нажатии на эту кнопку мы будем менять состояние isAuth на false.
    15.	Все работает корректно, но при обновлении страницы у нас сбрасывается состояние isAuth. Нужно где-то сохранять, авторизован пользователь или нет. Например, в LocalStorage. Проверку мы будем делать в App.js с помощью useEffect с пустым массивом зависимостей.
    16.	Переходим в файл App.js.
    17.	Внутри callback useEffect делаем проверку: если это значение есть, то мы делаем состояние isAuth true: if (localStorage.getItem("auth")){ setIsAuth(true) }.
    18.	Остается в момент авторизации что-то сохранять в localStorage. Переходим в файл Login.jsx.
    19.	В localStorage по ключу auth будем сохранять значение true: localStorage.setItem("auth", "true").
    20.	Так же в момент, когда мы выходим из приложения нам необходимо эту запись из localStorage удалять. Переходим в Navbar.jsx.
    21.	Добавляем функцию logout в которой проделываем аналогичные действия, только теперь мы будем удалять запись из localStorage: setIsAuth(false); localStorage.removeItem("auth");
    22.	Вешаем эту функцию на слушатель события нажатия.
		
## 13.	БЕСКОНЕЧНАЯ ЛЕНТА. ДИНАМИЧЕСКАЯ ПАГИНАЦИЯ. useObserver.	
    1. 	Подобный функционал нам позволит реализовать Intersection Observer API. Для реализации переходим в Posts.jsx к условию isPostsLoading.
    2. 	Переделаем запуск лоадера, что бы он не перезатирал список постов. Роутер будет показан в случае, когда isPostsLoading равен true, а список постов будем отрисовывать в любом случае.
    3. 	Сейчас, когда отправляем запрос на сервер и получаем ответ в состояние помещаем только ту порцию, которую вернул сервер. В случае с бесконечной лентой нам необходимо эти данные помещать в конец страницы. Поэтому в useFetching в setPosts мы создаем новый массив добавляем туда массив, который уже есть, и в конец добавляем то, что вернул нам сервер: setPosts([...posts, ...response.data]).
    4. 	На данный момент, когда мы меняем страницу, мы сразу же подгружаем набор постов, нам достаточно состояние с номером страницы page добавить в список зависимостей useEffect.
    5. 	Удаляем fetchPosts() из changePage.
    6. 	Теперь воспользуемся вторым useEffect, но он будет уже с пустым массивом зависимостей: useEffect(() => {},[]).
    7. 	Нам необходимо проинициализировать observer, так же нам необходимо получить ссылку на DOM элемент, который находится последним в списке. И когда этот элемент находится в зоне видимости окна браузера, будем подгружать новый элемент. Для получение элемента, нам необходимо воспользоваться хуком useRef() и этот референс передать в последний элемент: const lastElement = useRef().
    8. 	Создадим отдельный блок div, что бы по нему понимать, когда мы дошли до нужного элемента-индикатора подгрузки новых данных. Этот блок в последствии можно сделать невидимым. Как только этот блок будет попадать в зону видимости, нам необходимо подгружать новую порцию данных. Передадим в элемент ref={lastElement}, для того что бы мы могли получить доступ к DOM элементу: <div ref={lastElement} style={{height: 20, background: "red"}}></div>
    9. 	Когда этот блок будет попадать в область видимости будем выполнять определённые действия. По документации Intersection Observer API скопируем функционал в хук useEffect, который создавали заранее с пустым массивом зависимостей. И сразу же внесем некоторые правки.
    10.	Для того, чтобы у нас был доступ к observer компонента, создадим еще один ref. Он нужен не только к доступу к дом элементу, а так же в нем можно сохранять данные, что бы не терять их от рендера к рендеру: const observer = useRef();
    11.	Новый observer мы помещаем в поле current референса: var callback = function (entries, observer) {    }; observer.current = new IntersectionObserver(callback);
    12.	Необходимо указать, за каким элементом мы будем наблюдать. Для этого у observer вызываем функцию observe, и туда необходимо передать DOM элемент: observer.current.observe(lastElement.current).
    13.	Добавим console.log("ДИВ В ЗОНЕ ВИДИМОСТИ"); в callback внутри useEffect, что бы убедится что все работает.
    14.	Пока эта надпись появляется при появлении элемента в зоне видимости и при исчезновении из зоны видимости. В функции callback есть параметр entries - это массив элементов, за которыми мы наблюдаем. С помощью этого параметра мы можем взаимодействовать с isIntersecting, которое говорит в зоне видимости элемент или нет.
    15.	Делаем условие внутри callback: if (entries[0].isIntersecting) {выполнять действие}.
    16.	Внутри этого условия будем менять номер страницы setPage(page + 1).
    17.	Что бы обновления проходили не единожды в массив зависимостей добавим isPostsLoading.
    18.	Пока обновление проходит не совсем корректно, потому что на каждый рендер у нас создается новый observer и не удаляется старый. В useEffect необходимо добавить несколько условий: Если isPostsLoading равен true мы делаем return, и до создания нового observer даже не доходим. Далее мы делаем проверку, если observer уже создан, если в поле current что-то находится, то тогда мы должны отключить наблюдение за всеми элементами, за которыми наблюдает observer в текущий момент. Для этого вызываем у него функцию disconnect().
    19.	Добавим к условию entries[0].isIntersecting и условие page < totalPages.
    20.	Сделаем этот функционал переиспользуемым. Создаем новый ХУК и называем его useObserver.js .
    21.	Функция-хук будет аргументом принимать: референс того элемента - ref, за которым необходимо наблюдать; некоторый callback, который будет выполняться в том случае, когда элемент в зоне видимости.
    22.	Переносим код useEffect для обзервера в наш хук.
    23.	Внутри у нас есть некоторые ограничители, их мы так же будем принимать аргументами: будем принимать булиан флаг canLoad - это будет значение, которое будет ограничивать вызов внутренней функции; будем принимать булиан флаг isLoading - это наш isPostsLoading.
    24.	Поменяем название у внутренней функции, что бы не было конфликта имен. И внутри cb будем вызывать передаваемый callback.
    25.	Создаем observer = useRef.
    26.	Меняем lastElement на ref.
    27.	Вернемся в компонент Posts.jsx .
    28.	Вызываем useObserver куда передаем: первым параметром референс, за которым мы наблюдаем lastElement; вторым параметром условие, за которым мы наблюдаем page < totalPages; третим аргументом передаем isPostsLoading; четвертым аргументом передаем callback которым просто изменяем номер страницы.
    29.	Реализуем логику по работе с лимитом. Сейчас он всегда равен 10.
    30.	Переходим в файл Post.jsx
    31.	Под PostFilter добавим MySelect, где в value передвем limit.
    32.	Установим onChange где мы будем получать значение value и устанавливать его в состояение limit с помощью функции setLimit.
    33.	В качестве defaultValue передадим строку "Количество элементов на странице"
    34.	Так же передаем массив опций options, тут у нас будет несколько объектов с полями value и name: {value: 5, name: '5'}, {value: 10, name: '10'}, {value: 25, name: '25'}, {value: -1, name: 'Все посты'},
    35.	Такой функционал добавит возможность выбрать сколько постов показывать на странице. Либо по 5, либо по 10 по 25 либо будут подгружаться сразу все. Что бы подгрузить все сразу нужно указать -1.
    36.	Что бы наш селект заработал нам нужно в useEffect с зависимостью page добавить limit.
